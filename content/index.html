<!DOCTYPE html>
<html>
    <head>
        <title>Ziniki Deployer</title>
        <link rel="stylesheet" href="css/mobile.css" />
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=menu" />
    </head>
    <body>
        <div class="title"><span class="menu-icon material-symbols-outlined">menu</span>Ziniki Deployer</div>
        <div class='sidebar-menu'>
            <div class="sidebar-top">Home</div>
            <div class="sidebar-top">Philosophy</div>
            <div class="sidebar-top">Samples</div>
            <div class="sidebar-top">User Guide</div>
            <div class="sidebar-second">Command line syntax</div> <!-- including --teardown and --destroy -->
            <div class="sidebar-second">Language features</div> <!-- including vars, exprs, nesting, properties-->
            <div class="sidebar-second">Environment</div>
            <div class="sidebar-second">Modules</div>

            <div class="sidebar-top">Developer guide</div>
            <div class="sidebar-second">Phases</div>
            <div class="sidebar-second">Extension Points</div>
            <div class="sidebar-second">Adding extensions - building a module</div>
            <div class="sidebar-second">Start up code</div>
            <div class="sidebar-second">Base classes</div>
            <div class="sidebar-second">Coins</div>
            <div class="sidebar-top">Download</div>
        </div>
        <div>
            Most deployment tools (for example, Terraform or CloudFormation) seem to be written as an afterthought,
            with the most important criterion being how easy it is to build them, and to cover as much infrastructure as possible
            with the smallest amount of code possible.
            Little or no thoughts seem to be given to how easy it is to build, debug, validate and understand the configurations they are used to create. 
        </div>
        <div>
            Obviously, scripts or programs that are hard to understand are expensive to maintain and are more likely to contain bugs that are hard to spot.
            Identifying subtle security issues is guaranteed to be hard if you have to decipher a custom policy nested inside a JSON document.
            And yet, this is what platform engineers are expected to do when deploying expansive products. 
        </div>
        <p>
            Ziniki Deployer is different.  It is designed, from the ground up, to be a programming language that helps you to build modular,
            task-based scripts that are easy to understand and reason about.  Currently, it lacks support for a broad range of platforms and functions,
            but it is build in a _modular_ fashion that makes it possible to support those in a consistent way as they are needed.
            More importantly, it makes the features it does support easy to use.
        </p>
        <p>
            Ziniki Deployer has six major attributes that make it different to other deployment tools out there:
        </p>
        <ul>
            <li>It has a focus on <b>clarity</b>: scripts should clearly communicate what they do, and not get lost in the minutiae of how they do it;
                scripts should be written in a language that is natural for the task at hand, not some general-purpose markup language.
            </li>
            <li>It is <b>target based</b>: in their desire to pretend that it is possible to describe everything you want to do declaratively, most
                deployment tools lose sight of the fact that some operations require messy reality to be involved: servers may need restarting in order
                to notice a configuration change, for example.  Ziniki Deployer assumes that *you* know what processes you will want in place and allows
                you to create targets that affect just part of your infrastructure: starting and stopping instances or services in accordance with your
                needs.
            </li>
            <li>It is <b>task oriented</b>: Ziniki Deployer assumes that you have in mind "something that you want to do" and will just want to issue
                a command to do that.  It does not require you to cobble together a number of operations in some broader script: all the operations should
                be able to be placed inside a Ziniki Deployer script.
            </li>
            <li>It operates <b>idempotently></b>: CloudFormation attempts to pretend that it makes changes to infrastructure "atomically" and, if something
                goes wrong, starts to roll back the changes that it has made.  While this is a virtuous goal, the fact that AWS architecture is not, in fact,
                atomic means that you often get stuck in a state where some of the changes have been applied and some rolled back.  Ziniki Deployer does its
                best to ensure that the world is how it thinks it is before it starts operating (it gets its information about the state of the world directly
                from the source objects, not an internal "stack"), but if it does fail for any reason, it leaves the job "half done" and will then pick up
                where it left off after the (necessary) human intervention has resolved the problem.
            </li>
            <li>It is <b>modular</b>: how modular?  So modular that with no modules installed, Ziniki Deployer is not, in fact, a task-based deployment tool,
                but simply a parser.  Everything from the idea of <code>target</code>s to its understanding of AWS primitives comes from one or more modules.
                Although this means that natively it has no understanding of your environment, it also means that it is just as capable of supporting Azure
                as it is of supporting AWS.  It also means that if you don't like what we have provided, you can easily add your own.
            </li>
            <li>It expects you to use <b>composition</b>: there are idempotent primitives for "all" the cloud infrastructure elements.  It's even possible
                that support for these could be generated.  But the important point is that _you_ don't think that way.  A cloudfront distribution requires
                five objects to be built and linked together just so: the <code>cloudfront.distribution.fromS3</code> composite does that for you.  Likewise,
                the <code>lambda</code> and <code>api.gateway.v2</code> composites require you to provide all the necessary parameters and build and link
                all the primitives together.
            </li>
        </ul>
        <h2>A Worked Example</h2>
        <p>
            Let's look at how those work through the lens of a simple example, the script that deploys this website (yes, we eat our own dog food, here).
        </p>
        <div>
            The first thing to note about deployer scripts is that they are designed to be "semi-literate" in the tradition of Miranda, Haskell and
            FLAS.  We expect you to write more lines of description <it>about</it> your script than you do actual commands.
        </div>
        <div class="codeline">hello</div>
%readfile
deployment/deployer.dply
%segment
The core

        <p>
            And then we run to the end...
        </p>

%segment
%end
    </body>
</html>
